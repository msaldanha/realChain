// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/msaldanha/realChain/ledger (interfaces: LedgerClient)

// Package tests is a generated GoMock package.
package tests

import (
	context "context"
	gomock "github.com/golang/mock/gomock"
	ledger "github.com/msaldanha/realChain/ledger"
	grpc "google.golang.org/grpc"
	reflect "reflect"
)

// MockLedgerClient is a mock of LedgerClient interface
type MockLedgerClient struct {
	ctrl     *gomock.Controller
	recorder *MockLedgerClientMockRecorder
}

// MockLedgerClientMockRecorder is the mock recorder for MockLedgerClient
type MockLedgerClientMockRecorder struct {
	mock *MockLedgerClient
}

// NewMockLedgerClient creates a new mock instance
func NewMockLedgerClient(ctrl *gomock.Controller) *MockLedgerClient {
	mock := &MockLedgerClient{ctrl: ctrl}
	mock.recorder = &MockLedgerClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockLedgerClient) EXPECT() *MockLedgerClientMockRecorder {
	return m.recorder
}

// GetAddressStatement mocks base method
func (m *MockLedgerClient) GetAddressStatement(arg0 context.Context, arg1 *ledger.GetAddressStatementRequest, arg2 ...grpc.CallOption) (*ledger.GetAddressStatementResult, error) {
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetAddressStatement", varargs...)
	ret0, _ := ret[0].(*ledger.GetAddressStatementResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAddressStatement indicates an expected call of GetAddressStatement
func (mr *MockLedgerClientMockRecorder) GetAddressStatement(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAddressStatement", reflect.TypeOf((*MockLedgerClient)(nil).GetAddressStatement), varargs...)
}

// GetLastTransaction mocks base method
func (m *MockLedgerClient) GetLastTransaction(arg0 context.Context, arg1 *ledger.GetLastTransactionRequest, arg2 ...grpc.CallOption) (*ledger.GetLastTransactionResult, error) {
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetLastTransaction", varargs...)
	ret0, _ := ret[0].(*ledger.GetLastTransactionResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetLastTransaction indicates an expected call of GetLastTransaction
func (mr *MockLedgerClientMockRecorder) GetLastTransaction(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLastTransaction", reflect.TypeOf((*MockLedgerClient)(nil).GetLastTransaction), varargs...)
}

// GetTransaction mocks base method
func (m *MockLedgerClient) GetTransaction(arg0 context.Context, arg1 *ledger.GetTransactionRequest, arg2 ...grpc.CallOption) (*ledger.GetTransactionResult, error) {
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetTransaction", varargs...)
	ret0, _ := ret[0].(*ledger.GetTransactionResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTransaction indicates an expected call of GetTransaction
func (mr *MockLedgerClientMockRecorder) GetTransaction(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTransaction", reflect.TypeOf((*MockLedgerClient)(nil).GetTransaction), varargs...)
}

// Register mocks base method
func (m *MockLedgerClient) Register(arg0 context.Context, arg1 *ledger.RegisterRequest, arg2 ...grpc.CallOption) (*ledger.RegisterResult, error) {
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Register", varargs...)
	ret0, _ := ret[0].(*ledger.RegisterResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Register indicates an expected call of Register
func (mr *MockLedgerClientMockRecorder) Register(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Register", reflect.TypeOf((*MockLedgerClient)(nil).Register), varargs...)
}

// Verify mocks base method
func (m *MockLedgerClient) Verify(arg0 context.Context, arg1 *ledger.VerifyRequest, arg2 ...grpc.CallOption) (*ledger.VerifyResult, error) {
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Verify", varargs...)
	ret0, _ := ret[0].(*ledger.VerifyResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Verify indicates an expected call of Verify
func (mr *MockLedgerClientMockRecorder) Verify(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Verify", reflect.TypeOf((*MockLedgerClient)(nil).Verify), varargs...)
}

// VerifyTransaction mocks base method
func (m *MockLedgerClient) VerifyTransaction(arg0 context.Context, arg1 *ledger.VerifyTransactionRequest, arg2 ...grpc.CallOption) (*ledger.VerifyTransactionResult, error) {
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "VerifyTransaction", varargs...)
	ret0, _ := ret[0].(*ledger.VerifyTransactionResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// VerifyTransaction indicates an expected call of VerifyTransaction
func (mr *MockLedgerClientMockRecorder) VerifyTransaction(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VerifyTransaction", reflect.TypeOf((*MockLedgerClient)(nil).VerifyTransaction), varargs...)
}
